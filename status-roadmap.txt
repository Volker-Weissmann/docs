Current status

We're now at version 0.3, but we're still in beta, since there has been a a lot of new development with this release.

More in detail, the functional subset of the language seems now pretty solid. It has been used to write several non-trivial applications, the largest of which is the Cell compiler itself, and no major bugs have been found in almost two years now.

Relational automata are at this point almost complete, in the sense that all major features that are a must-have for version 1.0 have now been implemented. They still need more testing though: a lot of major features have been introduced with the current release, and more under-the-hood optimization work is planned for the next one, so extensive testing will have to wait until after version 0.4.

Reactive automata are at this stage still experimental. Not only they too haven't been tested anywhere enough but unlike their relational counterparts their design is still tentative and in a state of flux, and their implementation more complex. They're not expected to come out of beta until after version 1.0.

The documentation on this website is another work in progress. It covers almost all the features of the language, but rational, design guidelines and examples are still incomplete at this stage. And there's no documentation for the standard library yet.

So, again, this is a beta version, don't use it for anything important quite yet.


Road map

The next version of Cell, 0.4, will be dedicated exclusively to the optimization of relational automata (optimization of reactive automata and the functional subset of the language was done in 0.2), and won't introduce any new language features. It will be released in May (2019).

Version 0.5 will finish everything that is still left to do for 1.0, like a standard representation and syntactic sugar for common types like dates and time; improvements to the interface of the generated code; automatic generation of message handlers for inserting new entities or relationships in a relational automaton; and a minimal standard library with documentation. There will be also better support for debugging: right now when a message handler fails, it's hard to figure out exactly what went wrong, and this release with fix that. Finally, it will bring back the C++ and C# versions of the compiler (0.2, 0.3 and 0.4 all have been, or will be, Java-only). Expect the Java code generator in July 2019 and the C# one shortly after that, while the C++ version will take a bit longer.

Version 0.6 will only bring a few minor changes to the syntax of the language, along with a tool for automatically converting the old syntax to the new one. It'll be a very minor release, and it'll be available only a few weeks after the C++ version of 0.5.

Version 0.7 will be the released candidate for 1.0. It won't bring any new features, but it will focus exclusively on testing of relational automata (as explained before, the functional part of the language is already pretty solid, and reactive automata are expected to be still in beta for version 1.0). There's no release date yet.

Version 1.0 will be released once 0.7 has seen enough real world usage and is deemed solid enough to warrant the "1.0" label. That could potentially take a while, but the development of Cell will not stop in the meantime.

The first priority after 0.7 will be the implementation of at least the simplest versions of the network architecture.

There's also a long list of things to do for reactive automata. You can read about them {#{reactive-automata-future-work-link}#}.

For the functional subset of the language the most important priorities will be a proper implementation of array mutability, and balanced-tree implementations of sets and maps, to complement the current ones that use sorted arrays.

After 1.0 is released, development will focus again on relational automata, and the most important new features will be Datalog-like inference rules with memoization, and more powerful update models. The current update model has clear limitations, but it has a couple of important properties: state transitions are atomic (that is, only the states before and after the transition can be observed, and all intermediate ones are just an implementation detail that is hidden from the developer) and it is amenable to a parallel implementation. The new models will preserve these properties, while adding more flexibility and modularity.
